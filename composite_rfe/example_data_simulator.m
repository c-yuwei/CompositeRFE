%EXAMPLE_DATA_SIMULATOR
% Script example data simulator

clear variables %#ok<*NASGU>

%% Simulate data with small worldness (Task 1)

output_folder = [fileparts(which('DataSimulator')) filesep 'SIM_DATASET_TWO_GROUPS'];

% create simulated data for group 1
dsim_1 = DataSimulator('P_MAX', 0.02, 'P_MIN', 0.02, 'D', 4, 'N', 10, 'TIME_STEP', 200, 'N_SUB', 25, 'SIM_DIRECTORY', output_folder, 'SIM_GR_ID', 'SimGroup1');
graph_data_1 = dsim_1.get('SIM_G_DICT');

%yuxin add the circle plot for sim_data_1 with 5x5 panels
% draw group 1 data
figure;
tiledlayout(5, 5, 'Padding', 'compact', 'TileSpacing', 'compact');
for i = 1:25
    nexttile;
    G = graph(graph_data_1{i}, 'OmitSelfLoops');
    plot(G, 'Layout', 'circle', 'NodeLabel', {});
    title(['Sample ' num2str(i)]);
end

% create simulated data for group 2
dsim_2 = DataSimulator('P_MAX', 0.5, 'P_MIN', 0.5, 'D', 4, 'N', 10, 'TIME_STEP', 200, 'N_SUB', 25, 'SIM_DIRECTORY', output_folder, 'SIM_GR_ID', 'SimGroup2');
graph_data_2 = dsim_2.get('GRAPH_DATA');

%yuxin add the circle plot for sim_data_2 with 5x5 panels
% draw group 2 data
figure;
tiledlayout(5, 5, 'Padding', 'compact', 'TileSpacing', 'compact');
for i = 1:25
    nexttile;
    G = graph(graph_data_2{i}, 'OmitSelfLoops');
    plot(G, 'Layout', 'circle', 'NodeLabel', {});
    title(['Sample ' num2str(i)]);
end



% export to folder
dsim_1.get('EXPORT_BA');
dsim_1.get('EXPORT_DATA');
dsim_2.get('EXPORT_DATA');

%% Load simulated data and verify the built-in meausre functions (Task 2)
% Load Brain Atlas
im_ba = ImporterBrainAtlasXLS( ...
    'FILE', [output_folder filesep 'atlas.xlsx'], ...
    'WAITBAR', true ...
    );

ba = im_ba.get('BA');

% Load Group of Simulated Data
im_gr1 = ImporterGroupSubjectFUN_XLS( ...
    'DIRECTORY', [output_folder filesep 'SimGroup1'], ...
    'BA', ba, ...
    'WAITBAR', true ...
    );

gr1 = im_gr1.get('GR');

im_gr2 = ImporterGroupSubjectFUN_XLS( ...
    'DIRECTORY', [output_folder filesep 'SimGroup2'], ...
    'BA', ba, ...
    'WAITBAR', true ...
    );

gr2 = im_gr2.get('GR');

% Analysis FUN WU
a_WU1 = AnalyzeEnsemble_FUN_WU( ...
    'GR', gr1 ...
    );

a_WU2 = AnalyzeEnsemble_FUN_WU( ...
    'TEMPLATE', a_WU1, ...
    'GR', gr2 ...
    );

% Calculate individual network
clustering_WU1 = a_WU1.get('MEASUREENSEMBLE', 'Clustering').get('M');
clustering_WU2 = a_WU2.get('MEASUREENSEMBLE', 'Clustering').get('M');
clusteringAv_WU1 = a_WU1.get('MEASUREENSEMBLE', 'ClusteringAv').get('M');
clusteringAv_WU2 = a_WU2.get('MEASUREENSEMBLE', 'ClusteringAv').get('M');
sm_WU1 = a_WU1.get('MEASUREENSEMBLE', 'SmallWorldness').get('M');
sm_WU2 = a_WU2.get('MEASUREENSEMBLE', 'SmallWorldness').get('M');

%% Load simulated data and produce text book figures (Task 3)

% --------------------------- TASK 3 ------------------------------------
%  Load simulated data and produce textbook figures
%  1) Use the built-in method (graph + distances) to compute small-world path length and plot the results
%  2) Implement a custom function to manually compute the average shortest path length for each graph and compare the results

% Specify output folder
output_folder = [fileparts(which('DataSimulator')) filesep 'SIM_DATASET_VARYING_P'];

dsim = DataSimulator('P_MAX', 1, 'P_MIN', 0, 'D', 6, 'N', 50, 'TIME_STEP', 200, 'N_SUB', 50, 'DIRECTORY', output_folder, 'GR_ID', 'TEXT_BOOOK_DATA');

% Retrieve graph data and p values generated by dsim
ground_truth_graph_data = dsim.get('GRAPH_DATA');
p = dsim.get('P');

% Extract unique p values
unique_p = unique(p);
n_sub = dsim.get('N_SUB');

% (1) Compute the average shortest path length using the built-in distances() function
small_world_path_lengths_builtin = zeros(size(unique_p));

for idx = 1:length(unique_p)
    current_p = unique_p(idx);
    path_lengths = [];

    for i = 1:n_sub
        if p(i) == current_p
            % Construct the graph
            G = graph(ground_truth_graph_data{i}, 'OmitSelfLoops');
            % Compute shortest distances using the built-in function
            dists = distances(G);
            % Replace Inf with NaN
            dists(dists == Inf) = NaN;
            % Compute the average shortest path length for this graph
            path_lengths = [path_lengths; nanmean(dists(:))];
        end
    end

    % Store the average shortest path length for the given p value
    small_world_path_lengths_builtin(idx) = nanmean(path_lengths);
end

% (2) Compute the average shortest path length using a custom BFS function
small_world_path_lengths_custom = zeros(size(unique_p));

for idx = 1:length(unique_p)
    current_p = unique_p(idx);
    path_lengths = [];

    for i = 1:n_sub
        if p(i) == current_p
            % Retrieve adjacency matrix
            A = ground_truth_graph_data{i};
            % Compute the distance matrix
            distMat = computeShortestPathsBFS(A);
            % Replace Inf with NaN
            distMat(distMat == Inf) = NaN;
            % Compute the average shortest path length for this graph
            path_lengths = [path_lengths; nanmean(distMat(:))];
        end
    end

    % Store the average shortest path length for the given p value
    small_world_path_lengths_custom(idx) = nanmean(path_lengths);
end

% (3) Plot the results in two separate figures
% Figure 1: Results using built-in distances() function
figure;
plot(unique_p, small_world_path_lengths_builtin, '-o', 'LineWidth', 2);
xlabel('Connection Probability P');
ylabel('Small-world Path Length');
title('Small-world Path Length (Builtin distances)');
grid on;

% Figure 2: Results using custom BFS function
figure;
plot(unique_p, small_world_path_lengths_custom, '-x', 'LineWidth', 2);
xlabel('Connection Probability P');
ylabel('Small-world Path Length');
title('Small-world Path Length (Custom BFS)');
grid on;

disp('Plots generated successfully (two separate figures for comparison)!');

% (Optional) Export simulation data
dsim.get('EXPORT_BA');
dsim.get('EXPORT_DATA');

% Custom function: Compute shortest paths in an unweighted graph using BFS
function distMat = computeShortestPathsBFS(adj)
    % Description:
    %   adj: N x N adjacency matrix (0/1), unweighted graph
    %   distMat: N x N distance matrix
    %
    %   Perform BFS from each node to compute shortest paths to all other nodes.
    %   If a node is unreachable, the distance remains Inf.

    N = size(adj, 1);
    distMat = Inf(N, N);

    for startNode = 1:N
        distMat(startNode, startNode) = 0;  % Distance to itself is 0

        % BFS queue
        queue = [startNode];
        visited = false(1, N);
        visited(startNode) = true;

        while ~isempty(queue)
            currentNode = queue(1);
            queue(1) = []; % Dequeue

            % Find neighbors of currentNode
            neighbors = find(adj(currentNode, :) > 0);
            for neighbor = neighbors
                if ~visited(neighbor)
                    visited(neighbor) = true;
                    queue(end+1) = neighbor; %#ok<AGROW>
                    distMat(startNode, neighbor) = distMat(startNode, currentNode) + 1;
                end
            end
        end
    end
end

dsim.get('EXPORT_BA');
dsim.get('EXPORT_DATA');


%%

% load ba and data
im_ba = ImporterBrainAtlasXLS( ...
    'FILE', [output_folder filesep 'atlas.xlsx'], ...
    'WAITBAR', true ...
    );

ba = im_ba.get('BA');

im_gr = ImporterGroupSubjectFUN_XLS( ...
    'DIRECTORY', [output_folder filesep 'TEXT_BOOOK_DATA'], ...
    'BA', ba, ...
    'WAITBAR', true ...
    );

gr = im_gr.get('GR');

a_WU = AnalyzeEnsemble_FUN_WU( ...
    'GR', gr ...
    );

g_dict = a_WU.get('G_DICT');

graph_data = g_dict.get('IT_LIST');

%yuxin compare on the ground_truth_graph_data 

target_measure = 'PathLengthAv';

for i = 1:g_dict.get('LENGTH')
    pathlength_av(i) = g_dict.get('IT', i).get('M_DICT').get('IT', target_measure).get('M');
end

%yuxin add the plot of pathlength_av with respect to p 

%% Key feature configuration (Task 4)