%% ¡header!
DataSimulator < ConcreteElement (dsim, data simulator) is a simulator for simulating example data.

%%% ¡description!
XXX

%%% ¡seealso!
create_data_NN_CLA_FUN_XLS

%%% ¡build!
1

%% ¡props_update!

%%% ¡prop!
ELCLASS (constant, string) is the class of the data simulator.
%%%% ¡default!
'DataSimulator'

%%% ¡prop!
NAME (constant, string) is the name of the data simulator.
%%%% ¡default!
'Neural Network Dataset'

%%% ¡prop!
DESCRIPTION (constant, string) is the description of the data simulator.
%%%% ¡default!
'XXX'

%%% ¡prop!
TEMPLATE (parameter, item) is the template of the data simulator.
%%%% ¡settings!
'DataSimulator'

%%% ¡prop!
ID (data, string) is a few-letter code for the data simulator.
'DataSimulator ID'

%%% ¡prop!
LABEL (metadata, string) is an extended label of data simulator.
%%%% ¡default!
'DataSimulator label'

%%% ¡prop!
NOTES (metadata, string) are some specific notes about the data simulator.
%%%% ¡default!
'DataSimulator notes'
    
%% ¡props!

%%% ¡prop!
BA (parameter, item) is a brain atlas.
%%%% ¡settings!
'BrainAtlas'
%%%% ¡postprocessing!
ba = dsim.get('BA');
if ba.get('BR_DICT').get('LENGTH') == 0
    n = dsim.get('N');
    brain_regions = cell(1, n);
    for i = 1:n
        brain_regions{i} = BrainRegion( ...
            'ID', ['BR' num2str(i)], ... % Randomize ID, here use the number
            'LABEL', ['Region' num2str(i)], ... % random LABEL, index number
            'NOTES', ['notes' num2str(i)], ... % NOTE names according to the number corresponding to n
            'X', rand()*100 - 50, ... % X [-50, 50] 
            'Y', rand()*100 - 50, ... % Y [-50, 50] 
            'Z', rand()*100 - 50 ... % Z [-50, 50] 
            );
    end

    % Create BrainAtlas with dynamically generated BrainRegions
    ba = BrainAtlas( ...
        'ID', 'GeneratedAtlas', ...
        'LABEL', 'Dynamic Brain Atlas', ...
        'NOTES', 'Automatically generated brain atlas', ...
        'BR_DICT', IndexedDictionary('IT_CLASS', 'BrainRegion', 'IT_LIST', brain_regions) ...
        );
    dsim.set('BA', ba);
end

%%% ¡prop!
P_MAX (parameter, scalar) is the maximum probability for simulating Watts–Strogatz models.
%%%% ¡default!
1

%%% ¡prop!
P_MIN (parameter, scalar) is the minimum probability for simulating Watts–Strogatz models.
%%%% ¡default!
0

%%% ¡prop!
P (parameter, rvector) is a vector of probability for simulating Watts–Strogatz models.
%%%% ¡default!
0:0.1:1
%%%% ¡postprocessing!
n_sub = dsim.get('N_SUB');
p = dsim.get('P');
if ~isequal(length(p), n_sub)     % not sure, yuxin check
    p_min = dsim.get('P_MIN');
    p_max = dsim.get('P_MAX');
    step = (p_max - p_min) / (n_sub - 1);
    if step == 0
        dsim.set('P', p_max*ones(1, n_sub));
    else
        dsim.set('P', p_min:step:p_max);
    end
end

%%% ¡prop!
D (parameter, scalar) is a number of degree for a Watts–Strogatz model.
%%%% ¡default!
4

%%% ¡prop!
N (parameter, scalar) is a number of node for a Watts–Strogatz model.
%%%% ¡default!
68

%%% ¡prop!
TIME_STEP (parameter, scalar) is time_steps.
%%%% ¡default!
100

%%% ¡prop!
N_SUB (data, scalar) is a number of subject to be generated.
%%%% ¡default!
10

%%% ¡prop!
DIRECTORY (data, string) is the directory to export the FUN subject group files.
%%%% ¡default!
fileparts(which('BRAPH2.LAUNCHER'))

%%% ¡prop!
GR_ID (data, string) is the folder name to export the FUN subject group files.
%%%% ¡default!
'SIM_GR'

%%% ¡prop!
GRAPH_DATA (result, cell) is the Small_World_Graph.
%%%% ¡calculate!

n = dsim.get('N'); 
d = dsim.get('D'); 
p_list = dsim.get('P');
n_sub = dsim.get('N_SUB'); % the number of samples
% initialize the cell array with a random ID, in this case a number.
graph_data = cell(1, n_sub);

% generate networks with different p
for sub = 1:n_sub
    p_sub = p_list(sub);  % Take the current sample of p
    G = zeros(n); % create n x n null adjacency matrix
    half_d = d / 2; % nearest neighbor connection number

    % 1. First generate a regular ring structure
    for i = 1:n
        for j = 1:half_d
            neighbor = mod(i + j - 1, n) + 1;
            G(i, neighbor) = 1;
            G(neighbor, i) = 1;
        end
    end

    % 2. Perform reconnection operation (make sure p takes effect)
    for i = 1:n
        for j = 1:half_d
            if rand < p_sub  % Reconnect with probability p_sub
                neighbor = mod(i + j - 1, n) + 1;
                G(i, neighbor) = 0;
                G(neighbor, i) = 0;

                new_neighbor = i;
                while new_neighbor == i || G(i, new_neighbor) == 1
                    new_neighbor = randi(n); % Randomly select a new node
                end
                G(i, new_neighbor) = 1;
                G(new_neighbor, i) = 1;
            end
        end
    end

    graph_data{sub} = G; % Stores the graph generated by the current p_sub
end

value = graph_data;


%%% ¡prop!
SIM_DATA (result, cell) is the simulated data using the Watts–Strogatz model.
%%%% ¡calculate! 
% Get parameters
n_sub = dsim.get('N_SUB'); % Number of samples
n = dsim.get('N'); % Number of nodes in the network
time_step = dsim.get('TIME_STEP'); % Time step variable
graph_data = dsim.get('GRAPH_DATA');% Get cell array, small world matrix

% Generate N_SUB sets of data
for sub = 1:n_sub

    graph_data_cell = graph_data{sub}; % get the adjacency matrix of the current subject

    % 4. Compute a positive definite covariance matrix (ensure usability)
    graph_data_cell(1:n+1:end) = 1; % Set diagonal elements to 1 to prevent non-positive definiteness
    cov_matrix = graph_data_cell * graph_data_cell'; % Compute the positive definite covariance matrix

    % 5. Generate time series data
    mu = ones(1, n); % Set the mean vector
    R = mvnrnd(mu, cov_matrix, time_step); % Generate a time series following a multivariate normal distribution

    % 6. Normalize the time series
    mean_R = mean(R);
    std_R = std(R);
    R = (R - mean_R) ./ std_R; % Normalize the data

    % 7. Store in the cell array
    sim_data{sub} = R;
end

% 8. Returns all generated data
value = sim_data;

%%% ¡prop!
SIM_GR (result, item) is the group of subjectFUN for those simulated data.
%%%% ¡settings!
'Group'
%%%% ¡calculate!
sim_data = dsim.get('SIM_DATA');
n_sub = dsim.get('N_SUB');
p = dsim.get('P');

% Generate n BrainRegion instances
n = dsim.get('N')

ba = dsim.get('BA');


for i = 1:n_sub
    subs{i} = SubjectFUN( ...
        'ID', ['Subject FUN ' num2str(i)], ...
        'LABEL', ['Subject FUN ' num2str(i)], ...
        'NOTES', ['Notes on Subject FUN ' num2str(i)], ...
        'BA', ba, ...
        'FUN', sim_data{i} ...
        );
    subs{i}.memorize('VOI_DICT').get('ADD', VOINumeric('ID', 'P', 'V', p(i)))
end

value = Group( ...
    'ID', dsim.get('GR_ID'), ...
    'LABEL', 'Group label', ...
    'NOTES', 'Group notes', ...
    'SUB_CLASS', 'SubjectFUN', ...
    'SUB_DICT', IndexedDictionary('IT_CLASS', 'SubjectFUN', 'IT_LIST', subs) ...
    );

%%% ¡prop!
EXPORT_DATA (query, empty) exports a group of subjects with the simulated fMRI data to a series of XLSX file.
%%%% ¡calculate!
directory = dsim.get('DIRECTORY');
if ~exist(directory, 'dir')
    mkdir(directory)
end

gr = dsim.get('SIM_GR');
ex = ExporterGroupSubjectFUN_XLS( ...
    'DIRECTORY', directory, ...
    'GR', gr ...
    );
ex.get('SAVE');

value = {};

%%% ¡prop!
EXPORT_BA (query, empty) exports a brain atlas to XLSX file.
%%%% ¡calculate!
%%%YUXIN
directory = dsim.get('DIRECTORY');
if ~exist(directory, 'dir')
    mkdir(directory)
end

ba = dsim.get('BA');
file = [directory filesep 'atlas.xlsx'];
ex = ExporterBrainAtlasXLS( ...
    'FILE', file, ...
    'BA', ba ...
    );
ex.get('SAVE');
value = {};

%% ¡tests!

%%% ¡excluded_props!
[DataSimulator.TEMPLATE DataSimulator.EXPORT_DATA DataSimulator.BA]

